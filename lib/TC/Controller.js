/*jslint white: true, onevar: true, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true */
/*globals TC, jQuery */

(function ($) {

	// Prototype for all controllers
	TC.Controller = {
	
		// Hash to store the actual value of local vars
		local_vars: {},
	
		// For local vars specify only value and as
		// For local vars specify model and resource
		// opts.value - The initial value of the variable
		// opts.model - The server side model to bind to
		// opts.resource - the resource on the server side model
		// opts.as - an optional alias for local bindings.	If not specified
		//					 it defaults to opts.resource
		bindData: function (opts) {
			var controller, name, obj;
		
			controller = this;
			name = opts.as || opts.resource;
			obj = {
				bound_variable: name,
				invalidate: function () {
					return controller.invalidate(name);
				},
				get: function (callback) {
					return controller.get(name, callback);
				},
				set: function (value, scope) {
					return controller.set(name, value, scope);
				}
			};
			if (opts.value !== undefined) {
				obj.value = opts.value;
			}
			if (opts.model !== undefined && opts.resource !== undefined) {
				obj.model = opts.model;
				obj.resource = opts.resource;
			}
			this[name] = obj;
		},
	
		// This is called by the View.php class when embedding interface files in
		// the autogenerated js file.
		bindView: function (data) {
			var controller = this;
		
			// This recursive functions traverses the data tree and turns the raw data
			// into live objects.
			function bind_to_controller(component_array, parent) {
				var data = [];
				$.each(component_array, function (i, component) {
					var params, Constructor;

					// Get the appropriate constructor (Button, Dropdown, etc...)
					Constructor = TC.components[component.name];

					// Create a new instance passing in controller and component data
					component = new Constructor(controller, component);

					// Store reference to parent if there is one
					if (parent !== undefined) {
						component.parent = parent;
					}
				
					// Convert bindings to native references
					params = component.params;
					$.each(params, function (i, name) {
						if (i.substr(0, 1) === '@') {
							var key = i.substr(1);
							delete(params[i]);
							if (typeof controller[name] === 'function') {
								params[key] = function () {
									return controller[name](component);
								};
							} else {
								params[key] = controller[name];
							}
						}
					});


					// Call the initializer if there is one
					if (component.initialize) {
						component.initialize();
					}

					// Recursivly bind the children.
					if (component.children) {
						component.children = bind_to_controller(component.children, component);
					}
				
					return component;
				});
				return data;
			}
		
			// Kick off recursive function for each of the root nodes.
			controller.interface_data = bind_to_controller(data);
		},

		invalidate: function (name) {
			// TODO: pass invalidate through to real data provider
			// var obj = this[name],
			// 		key;
			// key = Util.stringify([obj.model, obj.resource]);
			// delete(remote_cache[key]);
			delete(this[name].value);
		},

		// Generic getter function
		get: function (name, callback) {
			var obj = this[name],
					self = this,
					key;

			// console.log("get", name, obj.value);
		
			// Unprimed async data source
			if (obj.value === undefined && obj.model && obj.resource) {
				// TODO: pass this through to real data provider
				// key = Util.stringify([obj.model, obj.resource]);
				// if (remote_cache[key] === undefined) {
				// 	// console.log("Starting ajax", obj);
				// 	Helper.remote_call(obj.model, "get_" + obj.resource, [], function (data) {
				// 		obj.value = data;
				// 		remote_cache[key] = data;
				// 		// console.log("Ajax done", data);
				// 		self.notify(name);
				// 		if (callback) {
				// 			callback(data);
				// 		}
				// 	});
				// 	return undefined;
				// } else {
				// 	obj.value = remote_cache[key];
				// }
			}
			return obj.value;
		},
	
		// Generic setter function
		set: function (name, value, scope) {
			// Only trigger if the value actually changed
			if (value !== this.local_vars[name] || typeof value === 'object') {
				// console.log("set", name, value, scope);
				var obj = this[name];
				obj.value = value;
				// TODO: pass this through to real data provider
				// if (obj.model) {
				// 	// console.log("saving remove value", obj);
				// 	Helper.remote_call(obj.model, "set_" + obj.resource, [value]);
				// }
				this.notify(name, scope);
			}
		},
	
		unlisten: function (name, scope) {
			this.listeners[name] = this.listeners[name].filter(function (listener) {
				return listener.scope !== scope;
			});
		},
	
		// Add a listener to a data bound variable
		listen: function (name, callback, scope) {
			var already = false;
			// console.log("Listen", callback, scope);
			if (this.listeners === undefined) {
				this.listeners = {};
			}
			if (this.listeners[name] === undefined) {
				this.listeners[name] = [];
			}
			
			$.each(this.listeners[name], function () {
				if (scope === this.scope) {
					already = true;
				}
			});
			if (already) {
				// console.log("Already registered", this.listeners);
				return;
			}
		
			this.listeners[name].push({callback: callback, scope: scope});
			// console.log("New array", this.listeners);
		},
	
		// Notify all event listeners
		notify: function (name, scope) {
			// console.log("Notify", name, "Scope", scope);
			var self = this;
			// console.log("Listeners", this.listeners);
			if (this.listeners && this.listeners[name]) {
				$.each(this.listeners[name], function () {
					if (!scope || this.scope !== scope) { 
						// console.log("Call", listener);
						this.callback.call(self, self[name].value);
					}
				});
			}
		},
	
		// Recursivly pre-calculate the width and height of every component since
		// IE6 can't do it on it's own.
		calcSizes: function (dimensions) {
			// Get initial dimensions, defaulting to first node
			dimensions = dimensions || {};
			dimensions.width = dimensions.width || this.interface_data[0].layout.width;
			dimensions.height = dimensions.height || this.interface_data[0].layout.height;
		
			// Recursivly apply dimensions 
			function calc(component, parent_dimensions) {
				var layout = component.layout, width, height;
			
				// Store the parent width and height in the layout
				layout.parent_width = parent_dimensions.width;
				layout.parent_height = parent_dimensions.height;

				if (component.children) {
					// New width is width if specified, or parent_width minux left and right if not.
					if (layout.width !== undefined) {
						width = layout.width;
					} else {
						width = parent_dimensions.width - layout.left - layout.right;
					}
					// Same for height, top, and bottom.
					if (layout.height !== undefined) {
						height = layout.height;
					} else {
						height = parent_dimensions.height - layout.top - layout.bottom;
					}
					// Apply recursivly for children with new parent dimensions
					$.each(component.children, function () {
						calc(this, {width: width, height: height});
					});
				}
			}
		
			// Kick off the recursive function starting at the root nodes of the view.
			$.each(this.interface_data, function () {
				calc(this, dimensions);
			});
		},
	
		// Turns the controller into haml that can be dom built
		render: function (dimensions) {
			var json;
		
			// Precalculate sizes for IE6
			if (!$.support.boxModel) {
				this.calcSizes(dimensions);
			}

			// Kick off recursive call for each root component
			json = [];
			$.each(this.interface_data, function () {
				json.push(this.render());
			});
			return json;
		}
	};
	
}(jQuery));