// Prototype for all controllers
TC.Controller = {
	
	// Hash to store the actual value of local vars
	local_vars: {},
	
	// For local vars specify only value and as
	// For local vars specify model and resource
	// opts.value - The initial value of the variable
	// opts.model - The server side model to bind to
	// opts.resource - the resource on the server side model
	// opts.as - an optional alias for local bindings.	If not specified
	//					 it defaults to opts.resource
	bindData: function (opts) {
		var controller, name, obj;
		
		controller = this;
		name = opts.as || opts.resource;
		obj = {
			bound_variable: name,
			invalidate: function () {
				return controller.invalidate(name);
			},
			get: function (callback) {
				return controller.get(name, callback);
			},
			set: function (value, scope) {
				return controller.set(name, value, scope);
			}
		};
		if (opts.value !== undefined) {
			obj.value = opts.value;
		}
		if (opts.model !== undefined && opts.resource !== undefined) {
			obj.model = opts.model;
			obj.resource = opts.resource;
		}
		this[name] = obj;
	},
	
	// This is called by the View.php class when embedding interface files in
	// the autogenerated js file.
	bindView: function (data) {
		var controller = this;
		
		// This recursive functions traverses the data tree and turns the raw data
		// into live objects.
		function bind_to_controller(component_array, parent) {
			return Util.map(component_array, function (component) {
				var params, Constructor;

				// Get the appropriate constructor (Button, Dropdown, etc...)
				Constructor = TC.components[component.name];

				// Create a new instance passing in controller and component data
				component = new Constructor(controller, component);

				// Store reference to parent if there is one
				if (parent !== undefined) {
					component.parent = parent;
				}
				
				// Convert bindings to native references
				params = component.params;
				Util.each_pair(params, function (i, name) {
					if (i.substr(0, 1) === '@') {
						var key = i.substr(1);
						delete(params[i]);
						if (typeof controller[name] === 'function') {
							params[key] = function () {
								return controller[name](component);
							};
						} else {
							params[key] = controller[name];
						}
					}
				});


				// Call the initializer if there is one
				if (component.initialize) {
					component.initialize();
				}

				// Recursivly bind the children.
				if (component.children) {
					component.children = bind_to_controller(component.children, component);
				}
				
				return component;
				
			});
		}
		
		// Kick off recursive function for each of the root nodes.
		controller.interface_data = bind_to_controller(data);
	},

	invalidate: function (name) {
		var obj = this[name],
				self = this,
				key;
		
		key = Util.stringify([obj.model, obj.resource]);
		delete(remote_cache[key]);
		delete(this[name].value);
	},

	// Generic getter function
	get: function (name, callback) {
		var obj = this[name],
				self = this,
				key;

		// console.log("get", name, obj.value);
		
		// Unprimed async data source
		if (obj.value === undefined && obj.model && obj.resource) {
			key = Util.stringify([obj.model, obj.resource]);
			if (remote_cache[key] === undefined) {
				// console.log("Starting ajax", obj);
				Helper.remote_call(obj.model, "get_" + obj.resource, [], function (data) {
					obj.value = data;
					remote_cache[key] = data;
					// console.log("Ajax done", data);
					self.notify(name);
					if (callback) {
						callback(data);
					}
				});
				return undefined;
			} else {
				obj.value = remote_cache[key];
			}
		}
		return obj.value;
	},
	
	// Generic setter function
	set: function (name, value, scope) {
		// Only trigger if the value actually changed
		if (value !== this.local_vars[name] || typeof value === 'object') {
			// console.log("set", name, value, scope);
			var obj = this[name];
			obj.value = value;
			if (obj.model) {
				// console.log("saving remove value", obj);
				Helper.remote_call(obj.model, "set_" + obj.resource, [value]);
			}
			this.notify(name, scope);
		}
	},
	
	unlisten: function (name, scope) {
		this.listeners[name] = this.listeners[name].filter(function (listener) {
			return listener.scope !== scope;
		});
	},
	
	// Add a listener to a data bound variable
	listen: function (name, callback, scope) {
		var already = false;
		// console.log("Listen", callback, scope);
		if (this.listeners === undefined) {
			this.listeners = {};
		}
		if (this.listeners[name] === undefined) {
			this.listeners[name] = [];
		}
		Util.each(this.listeners[name], function (part) {
			if (scope === part.scope) {
				already = true;
			}
		});
		if (already) {
			// console.log("Already registered", this.listeners);
			return;
		}
		
		this.listeners[name].push({callback: callback, scope: scope});
		// console.log("New array", this.listeners);
	},
	
	// Notify all event listeners
	notify: function (name, scope) {
		// console.log("Notify", name, "Scope", scope);
		var self = this;
		// console.log("Listeners", this.listeners);
		if (this.listeners && this.listeners[name]) {
			Util.each(this.listeners[name], function (listener) {
				if (!scope || listener.scope !== scope) { 
					// console.log("Call", listener);
					listener.callback.call(self, self[name].value);
				}
			});
		}
	},
	
	// Recursivly pre-calculate the width and height of every component since
	// IE6 can't do it on it's own.
	calcSizes: function (dimensions) {
		// Get initial dimensions, defaulting to first node
		dimensions = dimensions || {};
		dimensions.width = dimensions.width || this.interface_data[0].layout.width;
		dimensions.height = dimensions.height || this.interface_data[0].layout.height;
		
		// Recursivly apply dimensions 
		function calc(component, parent_dimensions) {
			var layout = component.layout, width, height;
			
			// Store the parent width and height in the layout
			layout.parent_width = parent_dimensions.width;
			layout.parent_height = parent_dimensions.height;

			if (component.children) {
				// New width is width if specified, or parent_width minux left and right if not.
				if (layout.width !== undefined) {
					width = layout.width;
				} else {
					width = parent_dimensions.width - layout.left - layout.right;
				}
				// Same for height, top, and bottom.
				if (layout.height !== undefined) {
					height = layout.height;
				} else {
					height = parent_dimensions.height - layout.top - layout.bottom;
				}
				// Apply recursivly for children with new parent dimensions
				Util.each(component.children, function (child) {
					calc(child, {width: width, height: height});
				});
			}
		}
		
		// Kick off the recursive function starting at the root nodes of the view.
		Util.each(this.interface_data, function (component) {
			calc(component, dimensions);
		});
	},
	
	// Turns the controller into haml that can be dom built
	render: function (dimensions) {
		
		var self = this;
		
		// Precalculate sizes for IE6
		if (window.is_ie6) {
			this.calcSizes(dimensions);
		}

		// Kick off recursive call for each root component
		return Util.map(this.interface_data, function (part) {
			return part.render();
		});
	}
};
